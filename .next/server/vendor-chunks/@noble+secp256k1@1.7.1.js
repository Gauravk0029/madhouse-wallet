"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+secp256k1@1.7.1";
exports.ids = ["vendor-chunks/@noble+secp256k1@1.7.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@noble+secp256k1@1.7.1/node_modules/@noble/secp256k1/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+secp256k1@1.7.1/node_modules/@noble/secp256k1/lib/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nexports.CURVE = CURVE;\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return exports.utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = exports.utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nconst vopts = { strict: true };\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return exports.utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(exports.utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK3NlY3AyNTZrMUAxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGFBQWE7QUFDbE4sbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5RUFBeUUsc0JBQXNCLG1CQUFtQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWZlLXBhc3NrZXlzLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStzZWNwMjU2azFAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9zZWNwMjU2azEvbGliL2luZGV4LmpzP2QzNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtc2VjcDI1NmsxIC0gTUlUIExpY2Vuc2UgKGMpIDIwMTkgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWxzID0gZXhwb3J0cy5zY2hub3JyID0gZXhwb3J0cy52ZXJpZnkgPSBleHBvcnRzLnNpZ25TeW5jID0gZXhwb3J0cy5zaWduID0gZXhwb3J0cy5nZXRTaGFyZWRTZWNyZXQgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLmdldFB1YmxpY0tleSA9IGV4cG9ydHMuU2lnbmF0dXJlID0gZXhwb3J0cy5Qb2ludCA9IGV4cG9ydHMuQ1VSVkUgPSB2b2lkIDA7XG5jb25zdCBub2RlQ3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmNvbnN0IF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IENVUlZFID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufSk7XG5leHBvcnRzLkNVUlZFID0gQ1VSVkU7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuY29uc3QgZW5kbyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIHNwbGl0U2NhbGFyKGspIHtcbiAgICAgICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgIH0sXG59O1xuY29uc3QgZmllbGRMZW4gPSAzMjtcbmNvbnN0IGdyb3VwTGVuID0gMzI7XG5jb25zdCBoYXNoTGVuID0gMzI7XG5jb25zdCBjb21wcmVzc2VkTGVuID0gZmllbGRMZW4gKyAxO1xuY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIGZpZWxkTGVuICsgMTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzKHgpIHtcbiAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgIGNvbnN0IHgyID0gbW9kKHggKiB4KTtcbiAgICBjb25zdCB4MyA9IG1vZCh4MiAqIHgpO1xuICAgIHJldHVybiBtb2QoeDMgKyBhICogeCArIGIpO1xufVxuY29uc3QgVVNFX0VORE9NT1JQSElTTSA9IENVUlZFLmEgPT09IF8wbjtcbmNsYXNzIFNoYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SmFjUG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEphY29iaWFuUG9pbnQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKYWNvYmlhblBvaW50IGV4cGVjdGVkJyk7XG59XG5jbGFzcyBKYWNvYmlhblBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCNmcm9tQWZmaW5lOiBleHBlY3RlZCBQb2ludCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmVxdWFscyhQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChwLngsIHAueSwgXzFuKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQWZmaW5lQmF0Y2gocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC56KSk7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC50b0FmZmluZUJhdGNoKHBvaW50cykubWFwKEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRKYWNQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgY29uc3QgWjFaMSA9IG1vZChaMSAqIFoxKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IG1vZChaMiAqIFoyKTtcbiAgICAgICAgY29uc3QgVTEgPSBtb2QoWDEgKiBaMloyKTtcbiAgICAgICAgY29uc3QgVTIgPSBtb2QoWDIgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgUzEgPSBtb2QobW9kKFkxICogWjIpICogWjJaMik7XG4gICAgICAgIGNvbnN0IFMyID0gbW9kKG1vZChZMiAqIFoxKSAqIFoxWjEpO1xuICAgICAgICByZXR1cm4gVTEgPT09IFUyICYmIFMxID09PSBTMjtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQodGhpcy54LCBtb2QoLXRoaXMueSksIHRoaXMueik7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBBID0gbW9kKFgxICogWDEpO1xuICAgICAgICBjb25zdCBCID0gbW9kKFkxICogWTEpO1xuICAgICAgICBjb25zdCBDID0gbW9kKEIgKiBCKTtcbiAgICAgICAgY29uc3QgeDFiID0gWDEgKyBCO1xuICAgICAgICBjb25zdCBEID0gbW9kKF8ybiAqIChtb2QoeDFiICogeDFiKSAtIEEgLSBDKSk7XG4gICAgICAgIGNvbnN0IEUgPSBtb2QoXzNuICogQSk7XG4gICAgICAgIGNvbnN0IEYgPSBtb2QoRSAqIEUpO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChGIC0gXzJuICogRCk7XG4gICAgICAgIGNvbnN0IFkzID0gbW9kKEUgKiAoRCAtIFgzKSAtIF84biAqIEMpO1xuICAgICAgICBjb25zdCBaMyA9IG1vZChfMm4gKiBZMSAqIFoxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0SmFjUG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGlmIChYMiA9PT0gXzBuIHx8IFkyID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKFgxID09PSBfMG4gfHwgWTEgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgY29uc3QgWjFaMSA9IG1vZChaMSAqIFoxKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IG1vZChaMiAqIFoyKTtcbiAgICAgICAgY29uc3QgVTEgPSBtb2QoWDEgKiBaMloyKTtcbiAgICAgICAgY29uc3QgVTIgPSBtb2QoWDIgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgUzEgPSBtb2QobW9kKFkxICogWjIpICogWjJaMik7XG4gICAgICAgIGNvbnN0IFMyID0gbW9kKG1vZChZMiAqIFoxKSAqIFoxWjEpO1xuICAgICAgICBjb25zdCBIID0gbW9kKFUyIC0gVTEpO1xuICAgICAgICBjb25zdCByID0gbW9kKFMyIC0gUzEpO1xuICAgICAgICBpZiAoSCA9PT0gXzBuKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEhIID0gbW9kKEggKiBIKTtcbiAgICAgICAgY29uc3QgSEhIID0gbW9kKEggKiBISCk7XG4gICAgICAgIGNvbnN0IFYgPSBtb2QoVTEgKiBISCk7XG4gICAgICAgIGNvbnN0IFgzID0gbW9kKHIgKiByIC0gSEhIIC0gXzJuICogVik7XG4gICAgICAgIGNvbnN0IFkzID0gbW9kKHIgKiAoViAtIFgzKSAtIFMxICogSEhIKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoWjEgKiBaMiAqIEgpO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICBjb25zdCBQMCA9IEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2FsYXIgPT09ICdiaWdpbnQnICYmIHNjYWxhciA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIFAwO1xuICAgICAgICBsZXQgbiA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghVVNFX0VORE9NT1JQSElTTSkge1xuICAgICAgICAgICAgbGV0IHAgPSBQMDtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgbGV0IGsxcCA9IFAwO1xuICAgICAgICBsZXQgazJwID0gUDA7XG4gICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgazJwID0gbmV3IEphY29iaWFuUG9pbnQobW9kKGsycC54ICogZW5kby5iZXRhKSwgazJwLnksIGsycC56KTtcbiAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICB9XG4gICAgcHJlY29tcHV0ZVdpbmRvdyhXKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyArIDEgOiAyNTYgLyBXICsgMTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMiAqKiAoVyAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICB3TkFGKG4sIGFmZmluZVBvaW50KSB7XG4gICAgICAgIGlmICghYWZmaW5lUG9pbnQgJiYgdGhpcy5lcXVhbHMoSmFjb2JpYW5Qb2ludC5CQVNFKSlcbiAgICAgICAgICAgIGFmZmluZVBvaW50ID0gUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3QgVyA9IChhZmZpbmVQb2ludCAmJiBhZmZpbmVQb2ludC5fV0lORE9XX1NJWkUpIHx8IDE7XG4gICAgICAgIGlmICgyNTYgJSBXKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50I3dOQUY6IEludmFsaWQgcHJlY29tcHV0YXRpb24gd2luZG93LCBtdXN0IGJlIHBvd2VyIG9mIDInKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlY29tcHV0ZXMgPSBhZmZpbmVQb2ludCAmJiBwb2ludFByZWNvbXB1dGVzLmdldChhZmZpbmVQb2ludCk7XG4gICAgICAgIGlmICghcHJlY29tcHV0ZXMpIHtcbiAgICAgICAgICAgIHByZWNvbXB1dGVzID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFcpO1xuICAgICAgICAgICAgaWYgKGFmZmluZVBvaW50ICYmIFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcmVjb21wdXRlcyA9IEphY29iaWFuUG9pbnQubm9ybWFsaXplWihwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoYWZmaW5lUG9pbnQsIHByZWNvbXB1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcCA9IEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgbGV0IGYgPSBKYWNvYmlhblBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSAxICsgKFVTRV9FTkRPTU9SUEhJU00gPyAxMjggLyBXIDogMjU2IC8gVyk7XG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7XG4gICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBsZXQgbiA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBsZXQgcG9pbnQ7XG4gICAgICAgIGxldCBmYWtlO1xuICAgICAgICBpZiAoVVNFX0VORE9NT1JQSElTTSkge1xuICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEsIGFmZmluZVBvaW50KTtcbiAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIsIGFmZmluZVBvaW50KTtcbiAgICAgICAgICAgIGsxcCA9IGNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgIGsycCA9IGNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIGVuZG8uYmV0YSksIGsycC55LCBrMnAueik7XG4gICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgIH1cbiAgICB0b0FmZmluZShpbnZaKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXMwID0gdGhpcy5lcXVhbHMoSmFjb2JpYW5Qb2ludC5aRVJPKTtcbiAgICAgICAgaWYgKGludlogPT0gbnVsbClcbiAgICAgICAgICAgIGludlogPSBpczAgPyBfOG4gOiBpbnZlcnQoeik7XG4gICAgICAgIGNvbnN0IGl6MSA9IGludlo7XG4gICAgICAgIGNvbnN0IGl6MiA9IG1vZChpejEgKiBpejEpO1xuICAgICAgICBjb25zdCBpejMgPSBtb2QoaXoyICogaXoxKTtcbiAgICAgICAgY29uc3QgYXggPSBtb2QoeCAqIGl6Mik7XG4gICAgICAgIGNvbnN0IGF5ID0gbW9kKHkgKiBpejMpO1xuICAgICAgICBjb25zdCB6eiA9IG1vZCh6ICogaXoxKTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGF4LCBheSk7XG4gICAgfVxufVxuSmFjb2JpYW5Qb2ludC5CQVNFID0gbmV3IEphY29iaWFuUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4pO1xuSmFjb2JpYW5Qb2ludC5aRVJPID0gbmV3IEphY29iaWFuUG9pbnQoXzBuLCBfMW4sIF8wbik7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSAlIF8ybiA9PT0gXzBuO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaXNTaG9ydCA9IGJ5dGVzLmxlbmd0aCA9PT0gMzI7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGlzU2hvcnQgPyBieXRlcyA6IGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzcyh4KTtcbiAgICAgICAgbGV0IHkgPSBzcXJ0TW9kKHkyKTtcbiAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgIGlmIChpc1Nob3J0KSB7XG4gICAgICAgICAgICBpZiAoaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdEJ5dGVPZGQgPSAoYnl0ZXNbMF0gJiAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0Qnl0ZU9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVW5jb21wcmVzc2VkSGV4KGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDEsIGZpZWxkTGVuICsgMSkpO1xuICAgICAgICBjb25zdCB5ID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheShmaWVsZExlbiArIDEsIGZpZWxkTGVuICogMiArIDEpKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoaGV4KTtcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBieXRlc1swXTtcbiAgICAgICAgaWYgKGxlbiA9PT0gZmllbGRMZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWRlciA9PT0gMHgwMiB8fCBoZWFkZXIgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWRlciA9PT0gMHgwNClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50LmZyb21IZXg6IHJlY2VpdmVkIGludmFsaWQgcG9pbnQuIEV4cGVjdGVkIDMyLSR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzLCBub3QgJHtsZW59YCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmICghWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlY292ZXJ5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlY292ZXI6IGludmFsaWQgcmVjb3ZlcnkgYml0Jyk7XG4gICAgICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2goZW5zdXJlQnl0ZXMobXNnSGFzaCkpO1xuICAgICAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgICAgICBjb25zdCByYWRqID0gcmVjb3ZlcnkgPT09IDIgfHwgcmVjb3ZlcnkgPT09IDMgPyByICsgbiA6IHI7XG4gICAgICAgIGNvbnN0IHJpbnYgPSBpbnZlcnQocmFkaiwgbik7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKC1oICogcmludiwgbik7XG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHMgKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gcmVjb3ZlcnkgJiAxID8gJzAzJyA6ICcwMic7XG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvMzJiU3RyKHJhZGopKTtcbiAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTtcbiAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlciBzaWduYXR1cmU6IHBvaW50IGF0IGluZmluaWZ5Jyk7XG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleChpc0NvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgdG9IZXgoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeCA9IG51bVRvMzJiU3RyKHRoaXMueCk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuaGFzRXZlblkoKSA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3h9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgMDQke3h9JHtudW1UbzMyYlN0cih0aGlzLnkpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9IZXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCh0cnVlKS5zbGljZSgyKTtcbiAgICB9XG4gICAgdG9SYXdYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1BvaW50IGlzIG5vdCBvbiBlbGxpcHRpYyBjdXJ2ZSc7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpIHx8ICFpc1ZhbGlkRmllbGRFbGVtZW50KHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2QoeSAqIHkpO1xuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBpZiAobW9kKGxlZnQgLSByaWdodCkgIT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIG1vZCgtdGhpcy55KSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5kb3VibGUoKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5hZGQoSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKG90aGVyKSkudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykubXVsdGlwbHkoc2NhbGFyLCB0aGlzKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFAgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcyk7XG4gICAgICAgIGNvbnN0IGFQID0gYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCB0aGlzICE9PSBQb2ludC5CQVNFID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSk7XG4gICAgICAgIGNvbnN0IGJRID0gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKFEpLm11bHRpcGx5VW5zYWZlKGIpO1xuICAgICAgICBjb25zdCBzdW0gPSBhUC5hZGQoYlEpO1xuICAgICAgICByZXR1cm4gc3VtLmVxdWFscyhKYWNvYmlhblBvaW50LlpFUk8pID8gdW5kZWZpbmVkIDogc3VtLnRvQWZmaW5lKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3kpO1xuUG9pbnQuWkVSTyA9IG5ldyBQb2ludChfMG4sIF8wbik7XG5mdW5jdGlvbiBzbGljZURFUihzKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChzWzBdLCAxNikgPj0gOCA/ICcwMCcgKyBzIDogcztcbn1cbmZ1bmN0aW9uIHBhcnNlREVSSW50KGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoYCk7XG4gICAgfVxuICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgcmVzWzFdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB0cmFpbGluZyBsZW5ndGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogYnl0ZXNUb051bWJlcihyZXMpLCBsZWZ0OiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07XG59XG5mdW5jdGlvbiBwYXJzZURFUlNpZ25hdHVyZShkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSB0YWc6ICR7Ynl0ZXNUb0hleChkYXRhKX1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGFbMV0gIT09IGRhdGEubGVuZ3RoIC0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YTogciwgbGVmdDogc0J5dGVzIH0gPSBwYXJzZURFUkludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICBjb25zdCB7IGRhdGE6IHMsIGxlZnQ6IHJCeXRlc0xlZnQgfSA9IHBhcnNlREVSSW50KHNCeXRlcyk7XG4gICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZzogJHtieXRlc1RvSGV4KHJCeXRlc0xlZnQpfWApO1xuICAgIH1cbiAgICByZXR1cm4geyByLCBzIH07XG59XG5jbGFzcyBTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnU2lnbmF0dXJlLmZyb21Db21wYWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9OiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCBzdHIgPSBhcnIgPyBieXRlc1RvSGV4KGhleCkgOiBoZXg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIDY0LWJ5dGUgaGV4YCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGhleFRvTnVtYmVyKHN0ci5zbGljZSgwLCA2NCkpLCBoZXhUb051bWJlcihzdHIuc2xpY2UoNjQsIDEyOCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2lnbmF0dXJlLmZyb21ERVI6IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gcGFyc2VERVJTaWduYXR1cmUoYXJyID8gaGV4IDogaGV4VG9CeXRlcyhoZXgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tREVSKGhleCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogciBtdXN0IGJlIDAgPCByIDwgbicpO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHMgbXVzdCBiZSAwIDwgcyA8IG4nKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRS5uID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucyA+IEhBTEY7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kKC10aGlzLnMsIENVUlZFLm4pKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHNIZXhMID0gc0hleC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBySGV4TCA9IHJIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleEwpO1xuICAgICAgICBjb25zdCByTGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4TCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwgKyBzSGV4TCArIDQpO1xuICAgICAgICByZXR1cm4gYDMwJHtsZW5ndGh9MDIke3JMZW59JHtySGV4fTAyJHtzTGVufSR7c0hleH1gO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUlJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUkhleCgpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKCFhcnJheXMuZXZlcnkoKGIpID0+IGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWQnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuY29uc3QgUE9XXzJfMjU2ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG5mdW5jdGlvbiBudW1UbzMyYlN0cihudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYmlnaW50Jyk7XG4gICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBQT1dfMl8yNTYpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG51bWJlciAwIDw9IG4gPCAyXjI1NicpO1xuICAgIHJldHVybiBudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpO1xufVxuZnVuY3Rpb24gbnVtVG8zMmIobnVtKSB7XG4gICAgY29uc3QgYiA9IGhleFRvQnl0ZXMobnVtVG8zMmJTdHIobnVtKSk7XG4gICAgaWYgKGIubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvcjogZXhwZWN0ZWQgMzIgYnl0ZXMnKTtcbiAgICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9OdW1iZXI6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke2hleH1gKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4JyArIGhleC5sZW5ndGgpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZnVuY3Rpb24gZW5zdXJlQnl0ZXMoaGV4KSB7XG4gICAgcmV0dXJuIGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBVaW50OEFycmF5LmZyb20oaGV4KSA6IGhleFRvQnl0ZXMoaGV4KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjYWxhcihudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSAmJiBudW0gPiAwKVxuICAgICAgICByZXR1cm4gQmlnSW50KG51bSk7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIGlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIHByaXZhdGUgc2NhbGFyOiAwIDwgc2NhbGFyIDwgY3VydmUubicpO1xufVxuZnVuY3Rpb24gbW9kKGEsIGIgPSBDVVJWRS5QKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gcG93Mih4LCBwb3dlcikge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IFA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzcXJ0TW9kKHgpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGNvbnN0IF82biA9IEJpZ0ludCg2KTtcbiAgICBjb25zdCBfMTFuID0gQmlnSW50KDExKTtcbiAgICBjb25zdCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKTtcbiAgICBjb25zdCBfNDRuID0gQmlnSW50KDQ0KTtcbiAgICBjb25zdCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh4ICogeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeCkgJSBQO1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbikgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbikgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4pICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4pICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24pICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgcnQgPSBwb3cyKHQyLCBfMm4pO1xuICAgIGNvbnN0IHhjID0gKHJ0ICogcnQpICUgUDtcbiAgICBpZiAoeGMgIT09IHgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcnQ7XG59XG5mdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8gPSBDVVJWRS5QKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbmZ1bmN0aW9uIGludmVydEJhdGNoKG51bXMsIHAgPSBDVVJWRS5QKSB7XG4gICAgY29uc3Qgc2NyYXRjaCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgc2NyYXRjaFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIG1vZChhY2MgKiBudW0sIHApO1xuICAgIH0sIF8xbik7XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBpbnZlcnQobGFzdE11bHRpcGxpZWQsIHApO1xuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBtb2QoYWNjICogc2NyYXRjaFtpXSwgcCk7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHNjcmF0Y2g7XG59XG5mdW5jdGlvbiBiaXRzMmludF8yKGJ5dGVzKSB7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gZ3JvdXBMZW4gKiA4O1xuICAgIGNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMpO1xuICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlSGFzaChoYXNoLCB0cnVuY2F0ZU9ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGggPSBiaXRzMmludF8yKGhhc2gpO1xuICAgIGlmICh0cnVuY2F0ZU9ubHkpXG4gICAgICAgIHJldHVybiBoO1xuICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgcmV0dXJuIGggPj0gbiA/IGggLSBuIDogaDtcbn1cbmxldCBfc2hhMjU2U3luYztcbmxldCBfaG1hY1NoYTI1NlN5bmM7XG5jbGFzcyBIbWFjRHJiZyB7XG4gICAgY29uc3RydWN0b3IoaGFzaExlbiwgcUJ5dGVMZW4pIHtcbiAgICAgICAgdGhpcy5oYXNoTGVuID0gaGFzaExlbjtcbiAgICAgICAgdGhpcy5xQnl0ZUxlbiA9IHFCeXRlTGVuO1xuICAgICAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIHRoaXMudiA9IG5ldyBVaW50OEFycmF5KGhhc2hMZW4pLmZpbGwoMSk7XG4gICAgICAgIHRoaXMuayA9IG5ldyBVaW50OEFycmF5KGhhc2hMZW4pLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgfVxuICAgIGhtYWMoLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnV0aWxzLmhtYWNTaGEyNTYodGhpcy5rLCAuLi52YWx1ZXMpO1xuICAgIH1cbiAgICBobWFjU3luYyguLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYyh0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGNoZWNrU3luYygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfaG1hY1NoYTI1NlN5bmMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hhRXJyb3IoJ2htYWNTaGEyNTZTeW5jIG5lZWRzIHRvIGJlIHNldCcpO1xuICAgIH1cbiAgICBpbmNyKCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudGVyID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIDEsMDAwIGsgdmFsdWVzIGZvciBzaWduKCksIGFsbCB3ZXJlIGludmFsaWQnKTtcbiAgICAgICAgdGhpcy5jb3VudGVyICs9IDE7XG4gICAgfVxuICAgIGFzeW5jIHJlc2VlZChzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmsgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDBdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgfVxuICAgIHJlc2VlZFN5bmMoc2VlZCA9IG5ldyBVaW50OEFycmF5KCkpIHtcbiAgICAgICAgdGhpcy5jaGVja1N5bmMoKTtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IHRoaXMuaG1hY1N5bmModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDFdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IHRoaXMuaG1hY1N5bmModGhpcy52KTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdGhpcy52LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy52Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTeW5jKCkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmluY3IoKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgdGhpcy5xQnl0ZUxlbikge1xuICAgICAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUuUDtcbn1cbmZ1bmN0aW9uIGttZFRvU2lnKGtCeXRlcywgbSwgZCwgbG93UyA9IHRydWUpIHtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IGsgPSB0cnVuY2F0ZUhhc2goa0J5dGVzLCB0cnVlKTtcbiAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGtpbnYgPSBpbnZlcnQoaywgbik7XG4gICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoayk7XG4gICAgY29uc3QgciA9IG1vZChxLngsIG4pO1xuICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gbW9kKGtpbnYgKiBtb2QobSArIGQgKiByLCBuKSwgbik7XG4gICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHNpZy5yID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7XG4gICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpIHtcbiAgICAgICAgc2lnID0gc2lnLm5vcm1hbGl6ZVMoKTtcbiAgICAgICAgcmVjb3ZlcnkgXj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnLCByZWNvdmVyeSB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJpdmF0ZUtleShrZXkpIHtcbiAgICBsZXQgbnVtO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnYmlnaW50Jykge1xuICAgICAgICBudW0gPSBrZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKGtleSkgJiYga2V5ID4gMCkge1xuICAgICAgICBudW0gPSBCaWdJbnQoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggIT09IDIgKiBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gaGV4VG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gZ3JvdXBMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDMyIGJ5dGVzIG9mIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIG51bSA9IGJ5dGVzVG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJpdmF0ZSBrZXk6IDAgPCBrZXkgPCBuJyk7XG4gICAgcmV0dXJuIG51bTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcHVibGljS2V5LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgIHNpZ25hdHVyZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21ERVIoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21TaWduYXR1cmUobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICBpZiAoYXJyKVxuICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgIGlmIChzdHIpXG4gICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gKiAyIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICogMjtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFNoYXJlZFNlY3JldDogZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgIGNvbnN0IGIgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljQik7XG4gICAgYi5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5leHBvcnRzLmdldFNoYXJlZFNlY3JldCA9IGdldFNoYXJlZFNlY3JldDtcbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBieXRlcy5sZW5ndGggPiBmaWVsZExlbiA/IGJ5dGVzLnNsaWNlKDAsIGZpZWxkTGVuKSA6IGJ5dGVzO1xuICAgIHJldHVybiBieXRlc1RvTnVtYmVyKHNsaWNlKTtcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzKGJ5dGVzKSB7XG4gICAgY29uc3QgejEgPSBiaXRzMmludChieXRlcyk7XG4gICAgY29uc3QgejIgPSBtb2QoejEsIENVUlZFLm4pO1xuICAgIHJldHVybiBpbnQyb2N0ZXRzKHoyIDwgXzBuID8gejEgOiB6Mik7XG59XG5mdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgIHJldHVybiBudW1UbzMyYihudW0pO1xufVxuZnVuY3Rpb24gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5KSB7XG4gICAgaWYgKG1zZ0hhc2ggPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2gsIG5vdCBcIiR7bXNnSGFzaH1cImApO1xuICAgIGNvbnN0IGgxID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgZCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgYml0czJvY3RldHMoaDEpXTtcbiAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dHJhRW50cm9weSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGV4dHJhRW50cm9weSA9IGV4cG9ydHMudXRpbHMucmFuZG9tQnl0ZXMoZmllbGRMZW4pO1xuICAgICAgICBjb25zdCBlID0gZW5zdXJlQnl0ZXMoZXh0cmFFbnRyb3B5KTtcbiAgICAgICAgaWYgKGUubGVuZ3RoICE9PSBmaWVsZExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbjogRXhwZWN0ZWQgJHtmaWVsZExlbn0gYnl0ZXMgb2YgZXh0cmEgZGF0YWApO1xuICAgICAgICBzZWVkQXJncy5wdXNoKGUpO1xuICAgIH1cbiAgICBjb25zdCBzZWVkID0gY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpO1xuICAgIGNvbnN0IG0gPSBiaXRzMmludChoMSk7XG4gICAgcmV0dXJuIHsgc2VlZCwgbSwgZCB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTaWcocmVjU2lnLCBvcHRzKSB7XG4gICAgY29uc3QgeyBzaWcsIHJlY292ZXJ5IH0gPSByZWNTaWc7XG4gICAgY29uc3QgeyBkZXIsIHJlY292ZXJlZCB9ID0gT2JqZWN0LmFzc2lnbih7IGNhbm9uaWNhbDogdHJ1ZSwgZGVyOiB0cnVlIH0sIG9wdHMpO1xuICAgIGNvbnN0IGhhc2hlZCA9IGRlciA/IHNpZy50b0RFUlJhd0J5dGVzKCkgOiBzaWcudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICByZXR1cm4gcmVjb3ZlcmVkID8gW2hhc2hlZCwgcmVjb3ZlcnldIDogaGFzaGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBhd2FpdCBkcmJnLnJlc2VlZChzZWVkKTtcbiAgICBsZXQgc2lnO1xuICAgIHdoaWxlICghKHNpZyA9IGttZFRvU2lnKGF3YWl0IGRyYmcuZ2VuZXJhdGUoKSwgbSwgZCwgb3B0cy5jYW5vbmljYWwpKSlcbiAgICAgICAgYXdhaXQgZHJiZy5yZXNlZWQoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhkcmJnLmdlbmVyYXRlU3luYygpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydHMuc2lnblN5bmMgPSBzaWduU3luYztcbmNvbnN0IHZvcHRzID0geyBzdHJpY3Q6IHRydWUgfTtcbmZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IHZvcHRzKSB7XG4gICAgbGV0IHNpZztcbiAgICB0cnkge1xuICAgICAgICBzaWcgPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICBpZiAob3B0cy5zdHJpY3QgJiYgc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoID0gdHJ1bmNhdGVIYXNoKG1zZ0hhc2gpO1xuICAgIGxldCBQO1xuICAgIHRyeSB7XG4gICAgICAgIFAgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBzaW52ID0gaW52ZXJ0KHMsIG4pO1xuICAgIGNvbnN0IHUxID0gbW9kKGggKiBzaW52LCBuKTtcbiAgICBjb25zdCB1MiA9IG1vZChyICogc2ludiwgbik7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKTtcbiAgICBpZiAoIVIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB2ID0gbW9kKFIueCwgbik7XG4gICAgcmV0dXJuIHYgPT09IHI7XG59XG5leHBvcnRzLnZlcmlmeSA9IHZlcmlmeTtcbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSBleHBvcnRzLnV0aWxzLnJhbmRvbUJ5dGVzKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNpZ246IEV4cGVjdGVkIHZhbGlkIG1lc3NhZ2UsIG5vdCBcIiR7bWVzc2FnZX1cImApO1xuICAgICAgICB0aGlzLm0gPSBlbnN1cmVCeXRlcyhtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgeyB4LCBzY2FsYXIgfSA9IHRoaXMuZ2V0U2NhbGFyKG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSkpO1xuICAgICAgICB0aGlzLnB4ID0geDtcbiAgICAgICAgdGhpcy5kID0gc2NhbGFyO1xuICAgICAgICB0aGlzLnJhbmQgPSBlbnN1cmVCeXRlcyhhdXhSYW5kKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZC5sZW5ndGggIT09IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2lnbjogRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgYXV4IHJhbmRvbW5lc3MnKTtcbiAgICB9XG4gICAgZ2V0U2NhbGFyKHByaXYpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2KTtcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gcG9pbnQuaGFzRXZlblkoKSA/IHByaXYgOiBDVVJWRS5uIC0gcHJpdjtcbiAgICAgICAgcmV0dXJuIHsgcG9pbnQsIHNjYWxhciwgeDogcG9pbnQudG9SYXdYKCkgfTtcbiAgICB9XG4gICAgaW5pdE5vbmNlKGQsIHQwaCkge1xuICAgICAgICByZXR1cm4gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXIodDBoKSk7XG4gICAgfVxuICAgIGZpbmFsaXplTm9uY2UoazBoKSB7XG4gICAgICAgIGNvbnN0IGswID0gbW9kKGJ5dGVzVG9OdW1iZXIoazBoKSwgQ1VSVkUubik7XG4gICAgICAgIGlmIChrMCA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBDcmVhdGlvbiBvZiBzaWduYXR1cmUgZmFpbGVkLiBrIGlzIHplcm8nKTtcbiAgICAgICAgY29uc3QgeyBwb2ludDogUiwgeDogcngsIHNjYWxhcjogayB9ID0gdGhpcy5nZXRTY2FsYXIoazApO1xuICAgICAgICByZXR1cm4geyBSLCByeCwgayB9O1xuICAgIH1cbiAgICBmaW5hbGl6ZVNpZyhSLCBrLCBlLCBkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2Nobm9yclNpZ25hdHVyZShSLngsIG1vZChrICsgZSAqIGQsIENVUlZFLm4pKS50b1Jhd0J5dGVzKCk7XG4gICAgfVxuICAgIGVycm9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IGV4cG9ydHMudXRpbHMudGFnZ2VkSGFzaDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuaW5pdE5vbmNlKGQsIGF3YWl0IHRhZyhUQUdTLmF1eCwgcmFuZCkpO1xuICAgICAgICBjb25zdCB7IFIsIHJ4LCBrIH0gPSB0aGlzLmZpbmFsaXplTm9uY2UoYXdhaXQgdGFnKFRBR1Mubm9uY2UsIHQsIHB4LCBtKSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUoYXdhaXQgdGFnKFRBR1MuY2hhbGxlbmdlLCByeCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5maW5hbGl6ZVNpZyhSLCBrLCBlLCBkKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuICAgIGNhbGNTeW5jKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSBleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCBleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2goVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nobm9yclZlcmlmeVN5bmMoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2hTeW5jKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2hhRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuc2Nobm9yciA9IHtcbiAgICBTaWduYXR1cmU6IFNjaG5vcnJTaWduYXR1cmUsXG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICBzaWduU3luYzogc2Nobm9yclNpZ25TeW5jLFxuICAgIHZlcmlmeVN5bmM6IHNjaG5vcnJWZXJpZnlTeW5jLFxufTtcblBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG5jb25zdCBjcnlwdG8gPSB7XG4gICAgbm9kZTogbm9kZUNyeXB0byxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuY29uc3QgVEFHUyA9IHtcbiAgICBjaGFsbGVuZ2U6ICdCSVAwMzQwL2NoYWxsZW5nZScsXG4gICAgYXV4OiAnQklQMDM0MC9hdXgnLFxuICAgIG5vbmNlOiAnQklQMDM0MC9ub25jZScsXG59O1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbiA9IGdyb3VwTGVuICsgODtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoIDwgbWluTGVuIHx8IGhhc2gubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODZgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBtb2QoYnl0ZXNUb051bWJlcihoYXNoKSwgQ1VSVkUubiAtIF8xbikgKyBfMW47XG4gICAgICAgIHJldHVybiBudW1UbzMyYihudW0pO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBleHBvcnRzLnV0aWxzLmhhc2hUb1ByaXZhdGVLZXkoZXhwb3J0cy51dGlscy5yYW5kb21CeXRlcyhncm91cExlbiArIDgpKSxcbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcG9pbnQgPT09IFBvaW50LkJBU0UgPyBwb2ludCA6IG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgY2FjaGVkLl9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICBjYWNoZWQubXVsdGlwbHkoXzNuKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9LFxuICAgIHNoYTI1NjogYXN5bmMgKC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBjb25jYXRCeXRlcyguLi5tZXNzYWdlcykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiBoYXNoLnVwZGF0ZShtKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhhc2guZGlnZXN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSBzaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhtYWNTaGEyNTY6IGFzeW5jIChrZXksIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBja2V5ID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBrZXksIHsgbmFtZTogJ0hNQUMnLCBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9IH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY29uY2F0Qnl0ZXMoLi4ubWVzc2FnZXMpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuc2lnbignSE1BQycsIGNrZXksIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSG1hYyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIGhtYWMtc2hhMjU2IGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaGEyNTZTeW5jOiB1bmRlZmluZWQsXG4gICAgaG1hY1NoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICB0YWdnZWRIYXNoOiBhc3luYyAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0ggPSBhd2FpdCBleHBvcnRzLnV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5zaGEyNTYodGFnUCwgLi4ubWVzc2FnZXMpO1xuICAgIH0sXG4gICAgdGFnZ2VkSGFzaFN5bmM6ICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgX3NoYTI1NlN5bmMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hhRXJyb3IoJ3NoYTI1NlN5bmMgaXMgdW5kZWZpbmVkLCB5b3UgbmVlZCB0byBzZXQgaXQnKTtcbiAgICAgICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgICAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdIID0gX3NoYTI1NlN5bmMoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zaGEyNTZTeW5jKHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIF9KYWNvYmlhblBvaW50OiBKYWNvYmlhblBvaW50LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV4cG9ydHMudXRpbHMsIHtcbiAgICBzaGEyNTZTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfc2hhMjU2U3luYylcbiAgICAgICAgICAgICAgICBfc2hhMjU2U3luYyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGhtYWNTaGEyNTZTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfaG1hY1NoYTI1NlN5bmM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgIGlmICghX2htYWNTaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9obWFjU2hhMjU2U3luYyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+secp256k1@1.7.1/node_modules/@noble/secp256k1/lib/index.js\n");

/***/ })

};
;